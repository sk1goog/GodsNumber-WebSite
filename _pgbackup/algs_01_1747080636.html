<!DOCTYPE html>
<html lang="de">
    <head>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <title>Algs 01 – Simulation</title>
        <!-- Bootstrap für einfache Zentrierung -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"/>
        <style>
    body { display: flex; flex-direction: column; align-items: center; margin: 0; padding: 0; }
    #simulator { width: 400px; height: 400px; margin-top: 2rem; }
    #controls { margin: 1rem 0; }
    #algo { width: 300px; padding: 0.25rem; }
    #start { padding: 0.25rem 0.5rem; margin-left: 0.5rem; }
  </style>
    </head>
    <body>
        <!-- Simulator-Canvas -->
        <div id="simulator"></div>
        <!-- Algorithmus-Eingabe + Start -->
        <div id="controls">
            <input id="algo" type="text" placeholder="Zugfolge, z.B. R U R' U"/>
            <button id="start">Animation starten</button>
        </div>
        <!-- Three.js & OrbitControls -->
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
        <!-- Simulation-Code -->
        <script>
  document.addEventListener("DOMContentLoaded", function() {
    const container = document.getElementById("simulator");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    // Kamera
    const aspect = container.clientWidth / container.clientHeight;
    const camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
    camera.position.set(5, 5, 5);
    camera.lookAt(0, 0, 0);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    // OrbitControls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 0, 0);

    // Licht
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Würfelgruppe & Cubies
    const cubeGroup = new THREE.Group();
    scene.add(cubeGroup);
    const cubies = [];
    const size = 1, gap = 0.05;

    // Erzeuge 27 Cubies (gelöstes Grundlayout)
    const faceColors = {
      R: 0xff0000, L: 0xffa500,
      U: 0xffffff, D: 0xffff00,
      F: 0x00ff00, B: 0x0000ff
    };

    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        for (let z = -1; z <= 1; z++) {
          const geom = new THREE.BoxGeometry(size, size, size);
          geom.clearGroups();
          for (let i = 0; i < 6; i++) geom.addGroup(i * 6, 6, i);

          const mats = Array(6).fill().map(() =>
            new THREE.MeshBasicMaterial({ color: 0x000000 })
          );

          // Farbe jeder sichtbaren Seite
          if (Math.abs(x - 1) < 0.01) mats[0].color.setHex(faceColors.R);
          if (Math.abs(x + 1) < 0.01) mats[1].color.setHex(faceColors.L);
          if (Math.abs(y - 1) < 0.01) mats[2].color.setHex(faceColors.U);
          if (Math.abs(y + 1) < 0.01) mats[3].color.setHex(faceColors.D);
          if (Math.abs(z - 1) < 0.01) mats[4].color.setHex(faceColors.F);
          if (Math.abs(z + 1) < 0.01) mats[5].color.setHex(faceColors.B);

          const cubie = new THREE.Mesh(geom, mats);
          cubie.position.set(
            x * (size + gap),
            y * (size + gap),
            z * (size + gap)
          );
          cubeGroup.add(cubie);
          cubies.push(cubie);
        }
      }
    }

    // Zug-Parser & Move-Map
    const moveMap = {
      R: { axis: new THREE.Vector3(1, 0, 0), dir: -1, slice: c => c.position.x > 0.5 },
      L: { axis: new THREE.Vector3(1, 0, 0), dir:  1, slice: c => c.position.x < -0.5 },
      U: { axis: new THREE.Vector3(0, 1, 0), dir: -1, slice: c => c.position.y > 0.5 },
      D: { axis: new THREE.Vector3(0, 1, 0), dir:  1, slice: c => c.position.y < -0.5 },
      F: { axis: new THREE.Vector3(0, 0, 1), dir: -1, slice: c => c.position.z > 0.5 },
      B: { axis: new THREE.Vector3(0, 0, 1), dir:  1, slice: c => c.position.z < -0.5 },
      M: { axis: new THREE.Vector3(1, 0, 0), dir:  1, slice: c => Math.abs(c.position.x) < 0.01 },
      E: { axis: new THREE.Vector3(0, 1, 0), dir:  1, slice: c => Math.abs(c.position.y) < 0.01 },
      S: { axis: new THREE.Vector3(0, 0, 1), dir: -1, slice: c => Math.abs(c.position.z) < 0.01 },
      x: { axis: new THREE.Vector3(1, 0, 0), dir: -1, whole: true },
      y: { axis: new THREE.Vector3(0, 1, 0), dir: -1, whole: true },
      z: { axis: new THREE.Vector3(0, 0, 1), dir: -1, whole: true }
    };
    function parseAlgorithm(str) {
      return str.trim().split(/\s+/).map(tok => ({
        face: tok[0],
        count: tok.endsWith('2') ? 2 : 1,
        prime: tok.endsWith("'")
      }));
    }

    // Animationsfunktionen
    function animateMove({ face, count, prime }, onComplete) {
      const move = moveMap[face];
      if (!move) { onComplete(); return; }
      const { axis, dir: baseDir, slice, whole } = move;
      const direction = baseDir * (prime ? -1 : 1);
      const total = Math.PI/2 * count;
      let rotated = 0;

      const sliceCubies = whole ? cubies.slice() : cubies.filter(slice);
      const tmp = new THREE.Group(); scene.add(tmp);
      sliceCubies.forEach(c => tmp.attach(c));

      (function step() {
        const delta = Math.min(0.1, total - rotated);
        tmp.rotateOnAxis(axis, direction * delta);
        rotated += delta;
        if (rotated < total) requestAnimationFrame(step);
        else {
          sliceCubies.forEach(c => cubeGroup.attach(c));
          scene.remove(tmp);
          onComplete();
        }
      })();
    }
    let animating = false;
    function runSequence(seq) {
      if (!seq.length) { animating = false; return; }
      animating = true;
      animateMove(seq.shift(), () => runSequence(seq));
    }

    // Start-Button
    document.getElementById('start').addEventListener('click', () => {
      if (animating) return;
      const seq = parseAlgorithm(document.getElementById('algo').value || '');
      runSequence(seq);
    });

    // Render-Loop
    (function render() {
      requestAnimationFrame(render);
      controls.update();
      renderer.render(scene, camera);
    })();

    // Resize-Handler
    window.addEventListener('resize', () => {
      const w = container.clientWidth, h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
  });
  </script>
    </body>
</html>